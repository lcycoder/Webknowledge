
[toc]

# IP地址

* 分为四段

* 分为两个部分
    1. 网络ID
    2. 主机ID
* ip地址的分类
    1. A类 0.0.0.0  127.255.255.255  
    2. B类 128.0.0.0  191.255.255.255
    3. C类 192.0.0.0 233.255.255.255
    4. D类 多播地址
    5. E类  

* 在向浏览器的地址栏中输入一个url按回车后，网络中都会发生什么？  
比如输入 www.baidu.com  

1. 看浏览器的缓存
本机host  C：windows/system32/drivers/etc/host  
127.0.0.1 localhost  指的 是本机的ip  
0.0.0.0  指的是不知道ip

## 五层网络模型

* 应用层 (HTTP DNS协议)
* http  
  * 请求：request
    * 请求头
      * 请求方式 url 协议版本 : 请求方式分为 get/post  （head，put，delete)
      * $\color{#FF0000}{get 和post 的区别}$

* 运输层 （TCP UDP）
* 网络层 (IP)
* 数据链路层 mac地址  
* 物理层  

### Cookie与Session

### html的正确打开方式

* B/S  和 C/S  
* 发送网络请求
    1. 浏览器输入网址（无法代码控制）
    2. location.href（页面会发生跳转）
    3. 带有src属性的标签（无法处理）
    4. 带有href属性的标签(无法处理)
    5. 带有action属性的标签（无法处理）
    6. ajax（可以代码控制，页面不会跳转，服务器端返回的数据可以继续用js处理)

```js
        var xhr = null;
        if (window.XMLHttpRequest){
            xhr = new XMLHttpRequest();
        } else {
        xhr= new ActiveXObject("Microsoft.XMLHttp");
        }
        xhr.open("get","http://developer.duyiedu.com/edu/testAjax");
        xhr.send();
        ```
* 跨域
    * 跨域访问资源
        * 带有src属性的资源都允许被跨域访问
        * 带有href属性的资源大部分允许被跨域访问
    * 哪些是跨域请求的资源
        1. 后端接口的数据
        2. 其他域的cookie
        3. 其他域的缓存
    * 怎么算跨域
        * 协议，域名，端口号，三者有一个不一样的就算跨域
    * 跨域这个行为发生在哪里
        1. 即使跨域了也可以发出请求
        2. 服务器端也可以接受
        3. 服务器端可以正常处理
        4. 服务器端正常返回数据
        5. 浏览器可以正常接受数据
        6. 接收到之后，浏览器发现当面页面的域和请求的域不同，判定为跨域  
    * 虽然跨域了，但是我们依然需要这个数据怎么办
        * 后端配合我们进行跨域
            1. jsonp（正常的情况下，返回的数据都是json格式）
            2. 后端设置Acess-Control—Allow-Origin属性以支持跨域
        * 后端不配合跨域
            1. iframe（只能显示，不能控制）
            2. 通过后端代理
```js
var xhr = null;
        if (window.XMLHttpRequest){
            xhr = new XMLHttpRequest();
        } else {
        xhr= new ActiveXObject("Microsoft.XMLHttp");
        }
        console.log(xhr.readyState);
        xhr.open("get","http://developer.duyiedu.com/edu/testAjax");
        console.log(xhr.readyState);
        xhr.onreadystatechange = function(){
            //readystate == 4 请求已完成，已经接受到数据
            //status == 200 网络请求，结果都会有一个状态码，来表示这个请求是否正常
            //2** 表示成功
            //3** 重定向
            //4** 客户端错误
            //5** 服务端错误
            if（xhr.readyState == 4 && xhr.status == 200){
                alert(xhr.responseText);
            }
        }
        xhr.send();//如果open第三个参数传true或者不传，为异步模式，false为同步模式
        //计算机的世界里，异步表示一块进行。
```

```js
    $.ajax{
        url:"http://developer.duyiedu.com/edu/testJsonp",
        type:"get";
        dataType:"jsonp";
        success:function(data){
            console.log(data);
        }

    }
```

* jsonp跨域  
    只能使用get方法，如果使用post，会自动转换成get方法
    但在Jquery里，Jquery会判断是否是同源的，如果同源，设置的get就是get，设置的post就是post  
    如果不同源，那么只能使用get。
* JSONP原理  
  * 前端部分  
        1. 判断是否同源，如果同源，发送一个普通的ajax
        2. 如果不同源，则生成一个script标签，随机生成一个callback名字，并创建这个名字的方法。
        3. 设置script的src，并设置要请求的接口。
        4. 把callback拼接在后面。
    * 后端部分
        1. 后端接受到请求并准备数据。
        2. 把要返回的数据用callback的值和括号包裹起来返回。
    * 浏览器部分
        1. 浏览器把接收到的数据当做js代码来执行
        2. 执行了一个名为callback的方法，这样就收到了后端返回给我们的对象
